// RS-триггер
module RStrigger (out,x,xdop);
   // Определение входных и выходных параметров:
   // - x - S;
   // - xdop - R;
   // - out - !Q.
   input x,xdop;
   output out;

   // Определение регистровых параметров
   reg res;

   // module RStrigger — описание и RS-триггера на И-НЕ, и RS-триггера на ИЛИ-НЕ.
   // Предполагается, что до начала работы на все RS-триггеры поступает комбинация хранения.
   // Состояние триггера меняется, если изменится значение переменных x или xdop.
   always @(xdop or x)
   begin
      // Если изменить на противоположный сигнал на входе R, то в триггер пишем 0
      if (~xdop)
         res = 0;
      // А если изменить на противоположный сигнал на входе S, то в триггер пишем 1
      else if (~x)
         res = 1;
      end
   // инвертируем и выдаем значение триггера на выход:
   assign out = !res;
endmodule

// Испульсный фильтр
module Filter (OutResult, X, A, B);
   // Определение входных и выходных параметров:
   // - X - фильтруемый сигнал;
   // - A, B - дополнительные сигналы.
   input   X, A, B;

   // Выходной порт - Результат - Отфильтрованный сигнал
   output  OutResult;

   // Вызываем стандартные модули, выполняющие логические операции
   // Инвертирования с именами NOT1 и NOT2
   // Инвертируем переменные А и В и присваиваем значения
   // Переменным AInv и BInv соответственно
   not NOT1 (AInv, A);
   not NOT2 (BInv, B);

   // Вызываем 4 раза модуль RSTrigger, т.к. у нас в схеме 4 триггера,
   // Подставляя соответствующие параметры входных сигналов данного модуля
   RStrigger call1 (ou1, X, A);
   RStrigger call2 (ou2, X, B);
   RStrigger call3 (ou3, X, AInv);
   RStrigger call4 (ou4, X, BInv);

   // Вызов модуля, выполняющего логическую операцию И с именем AND1:
   and  AND1 (OutResult,ou1, ou2, ou3, ou4);
endmodule

